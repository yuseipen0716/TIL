## JavaScriptにおける非同期処理まとめ

そもそも同期処理、非同期処理ってなんだ

### 同期処理

前の処理の終了を待ってから次へ進む処理。

ex. JavaScriptで関数を呼び出すと、その関数の結果を待って次の処理へ進む

### 非同期処理

前の処理の完了を待たずに次の処理へ進む処理

複雑な画像処理やAPIからのデータ取得が必要な処理など、大きな処理を同期処理で行ってしまうと、何もできずに待機する時間ができてしまう。

そんなときに、時間のかかる処理については、処理の開始だけを依頼して、一旦次の処理に進むという感じみたい。

JavaScriptはシングルスレッドで実行される言語(処理の流れを一つしか持たない)であり、またWebブラウザはJavaScriptの実行やユーザからの入力の
受付を同じイベントループで行うため、非同期処理が非常に重要になってくる。

JavaScriptで非同期処理を実現する手段は主に以下の二つ

- コールバック関数
- Promise

### コールバック関数

関数の引数として関数を渡しておいて、都合のいいときに呼び出してもらう。関数の使い方に対する呼称

イベントハンドラとかイベントリスナなどがコールバック関数としてよく使われる?

イベントハンドラなどは基本的に設定したあとで発生したイベントしか補足できない。また、「画像表示」ボタンを押して表示されたら「表示が完了しました」と通知を出す処理
を書いたとして、そしたら表示に失敗したときはどうなる?みたいに、条件分岐を書かないといけない。コードの量が増えれば増えるほど、複雑になる。

また関数の入れ子が深くなりすぎて大変になることも(callback hell)

コールバック関数が得意→何度も発生するイベントをその都度処理する用途

一般的な非同期処理全般に適した手法とは言えない。

### Promise

Promise → 「まだ完了していない（かもしれない）結果」をあらわすオブジェクト

Promiseを使用する非同期関数を呼び出す→即座にPromiseオブジェクトが返却される。(処理の完了、未完了問わず)

Promiseオブジェクトには完了後の処理をthen()メソッドの引数として渡すことができる

コールバック関数の場合、非同期処理を複数から見合わせると、インデントが深くなり大変なことになっていたが、Promiseの場合、
then()メソッドをつなげることでそれを実現することができる。(Promiseチェーン)

Promiseチェーンを使えば、インデントが深くなってしまうこともない。

#### Promiseがとりうる非同期処理実行状況

- `<pending>` 保留中(処理が成功も失敗もしていない状態)
- `<fullfilled>` 履行済み(処理が成功した状態)
- `<rejected>` 棄却済み(処理が失敗した状態)

#### 完了時の処理

- then()
- catch()
- finally()



履行済みと棄却済みを合わせて→`settled` (成功または失敗した状態)






### 引用・参考
> O'REILLY ハンズオンJavaScript
