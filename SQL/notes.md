## SQLメモ

スッキリわかるSQL入門をやっています。その中でハッとしたことをメモしておくファイル。

### NULLかどうかの判断をするためには = は使えない

NULLかどうかの判断には`IS NULL`とか`IS NOT NULL`を使う。`=`は使えないことを忘れないように。

---

### COALESCE関数

NULLの部分に固定値を入れて取得できる。

COALESCE関数を使ってNULLのところに指定データを入れたいときは元の列のデータ型を指定データの型に合わせる必要があるみたい

---


### 特定のパターンに一致した部分を探すときはLIKE演算子

```
式　LIKE パターン文字列
```

パターン文字 | 意味
--- | ---
% | 任意の0文字以上の文字列
_ | 任意の1文字

たとえば%などのパターン文字を検索対象としたいときにはエスケープしないといけない。

そのときは

```
式　LIKE パターン文字列 ESCAPE 'エスケープしたい文字'
```

としてあげる。

---
### 主キーとは

　全く同じ内容の行が二つあったときに、上の1行だけ消したい　という処理はできない？（難しい？）
 
 会社でいう職員番号のようなものがあれば、例えば同姓同名の社員がいても区別がつく。
 
 このように **「この値を指定することで、ある行を完全に特定できる」** 役割をもつ列のことを主キーという。
 
 「社員テーブル」における社員番号は当たり前のように列として作成される主キーで自然キーと呼ぶ
 
 「家計簿テーブル」のような、本来ではIDなどの情報がないが、それぞれの行を区別するために作る「入金ID」等の主キーのことは人工キーとか代替キーとよぶみたい。
 
 たとえば、社員IDみたいな主キーがない場合でも、「氏名」「住所」「生年月日」というような複数の情報である行が特定できるようにする場合、それを複合キーとよぶ
 
 ---
 
 ### 外部キー
 
 ある2つのテーブルの行に情報としての関連がある場合、その関連をリレーションシップという。
 
 その場合、テーブル1において、テーブル2の主キーなど、関連行を示すための値を格納する。これを外部キーという。
 
 外部キー列は、その行が他のテーブルのどの行と関連しているのかを明らかにする。
 
 例えば、外部キーを設定せず、一つのテーブルだけで押し切ろうとする場合、カテゴリー１をカテゴリーAにrenameしたい時に大変。データの量が100万行とかだと…
  
 そこで、外部キーを設定しておけば、テーブル2のカテゴリー名の列の値を変更するだけで済む。
 
 ---
 
 ### SELECTに列名以外の値を
 
 SELECTの部分って列名しか入らないと思っていたけど、計算式とか、固定値も入るみたい。
 
 計算式を入れる（SELECT 出金額+100みたいな）と、出金額に100を足した数が取得される。
 
 '固定値'のように、固定値を指定すると、「固定値」という値で全て取得される。
 
 計算式などを指定して取得してくる場合、列名の部分が「出金額+100」のようになってしまうため、`AS`を利用して別名を指定する。
 
 ---
 
 ### 現在の日付を取得する関数
 
 `CURRENT_DATE`関数を使うと、現在の日付を取得できる。
 
 INSERTのVALUESのところに、CURRENT_DATEを入れておくと、追加した日付を明示できる
 
 ---
 
 ### COUNT関数
 
 検索結果の行数を求める際にCOUNT関数という集計関数を使う。
 
 そもそも集計関数というのは普通の関数(LENGTHなど)が一つの行に対して一つの戻り値を返すのに対して、集計関数は指定した列、検索条件に対して一回実施し、戻り値も日等受け取るのみのもの。
 
 SUMみたいな合計を求める関数がそれにあたる。
 
 COUNT関数は検索結果の行数を求めると書いたが、
 
 ```
 COUNT(*)
 ```
 
 ```
 COUNT(列)
 ```
 
 という２つの書き方がある。
 
 ``` SQL
 SELECT COUNT(*) AS 別名
 FROM テーブル
 WHERE 列名 = '検索条件'
 ```
 
 のようにして使うことになる。
 
 `COUNT(*)`と`COUNT(列)`はNULLの扱い方に少し差がある。前者はNULL行も含めて行数を数えるが、後者はNULL行を除いて数える。
 
  ``` SQL
 SELECT COUNT(DISTINCT カテゴリー) AS 別名
 FROM テーブル
 WHERE カテゴリー = '検索条件'
 ```
 
 のようにしてあげると、カテゴリーという列の重複を取り除いて行数を数えることができるため、カテゴリーが何種類あるのか調べたい時には便利ですね。
 
 ---
 
 ### グループ化
 
　収支の集計表などを作る際に、費目ごとの合計値を出したくなると思うが、その度にSELECT、SUM、WHERE(費目を指定)とするのは面倒。費目でグループ化するとよい。
 
 #### GROUP BYでグループ化
 
 ``` SQL
 SELECT グループ化の基準列名, 集計関数
 FROM テーブル名
 (WHERE 絞り込み条件)
GROUP BY グループかの基準列名
```
グループ集計を行う際に、「合計が0より大きいものを選択」というような条件を指定したいことがあるが、集計関数をWHERE句に書くとエラーがでる。

グループ集計の流れというか、仕組みは以下のようになる。

1. 大元のテーブルからWHERE句によって行を絞り込む
2. グループごとに検索結果を分類
3. 分類されたそれぞれのグループに対して集計関数があてられて、グループごとの集計結果が出る。

この流れの理解が結構重要。**WHEREの処理が行われている段階では集計関数が当たっていない**ため、集計関数を条件として指定することはできないってわけ。

集計関数の結果を条件として指定したい時にはHAVING句を使う。HAVING句に記述した内容は上記したグループ集計の流れの3.の次に評価される。

 ``` SQL
 SELECT グループ化の基準列名, 集計関数
 FROM テーブル名
 (WHERE 絞り込み条件)
GROUP BY グループかの基準列名
HAVING 集計関数の結果を条件に指定
```
---
### 集計テーブル

集計関数を使用して支出の合計を算出し参照するとして、それらの処理を支出合計をみたい時に毎回行うと、毎回処理を回さないといけないことになり、少ないデータであればいいが、データの量が膨大になってくると、
集計に時間がかかってしまう可能性もある。

そういった事態を防ぐために？毎回の処理を軽くするためにも、集計テーブルのような新しいテーブルを作成し、集計した結果をそのテーブルにINSERTしていくようにすれば、合計を知りたい時も関数を使わず、SELECT文だけで済む。

ただそうすると、データを更新したあとの結果が反映されず、合計値がずれてくる恐れがある。そのため、データを更新したタイミングなどをトリガーにして、集計テーブルの方も更新するようにする必要がある。

この方法についてはまた後日学習します。

---
### 副問い合わせ

ほかのSQL文の中で登場するSELECT文。丸括弧でくくって記述。（SELECT文をネスト）

服問い合わせの中身はSELECT文なので、副問い合わせの形としては以下のようなパターンに分けることができる。

- 単一の値の代わりとして、副問い合わせの検索結果を用いる。
- 複数の値の代わりとして、副問い合わせの検索結果を用いる。
- 表の値の代わりとして、副問い合わせの検索結果を用いる。
---

### NOT IN 演算子とNULLの話

``` SQL
SELECT * FROM DB
WHERE カテゴリー NOT IN ('A', 'B', NULL)
```

という風にNOT IN演算子の右辺にNULLがあると困ったことに。

NOT IN演算子では右辺に列挙された値を不等号を使用して一つ一つ比較する。（`<>'A'`がTRUEかどうか、`<>'B'`がTRUEかどうか、、、のように。）

NULLは`=`や`<>`で評価することができない。`IS NULL`とか`IS NOT NULL`を使って評価してあげないといけないのに、NOT IN演算子の右辺にNULLがあると、

```
<>NULL → False（正しくは「不明」となり正しく評価されない？）
```

となってしまう。NOT INは右辺で列挙した値全てと等しくない値を検索するわけなので、ここに正しく評価できないNULLが入ってしまうと、「NULLと等しいものも等しくないものもわからないよ」となってしまい、
検索の結果としては何も帰って来なくなる。

これを防ぐためにはWHERE句にIS NOT NULLを入れてあげたり、COALESCE関数を使って、NULLのデータを別値に置き換えてあげる必要がある。

---
### timestamp型について

YYYY-MM-DD-hh-mm-ssで表現。データを保存すると、UTCに直され、データを引き出すときにUTCから現在のタイムゾーンへ変換される。

誰が見ても、その地域のいい感じの時間になるようなイメージ？ 






 
 
 
 
 
 
 
 
 
 
 
