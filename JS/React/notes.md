## React学習メモ

### JSXってなに


### キーワード殴り書き

- 要素→Reactアプリケーションの最小単位の構成ブロック
- 要素 not equal コンポーネント
  - 要素はコンポーネントを**構成するもの**
- React要素はプレーンなオブジェクト。
- React要素はイミュータブルなので、その子要素や属性は変更不可。必要に応じて要素や属性を変えるのではなく、特定のUIのある時点を切り取ったようなもの??
- 時間の経過により、どのようにUIが変更されるかを考えるかを考えるよりも、任意の時点においてUIがどのように見えるべきかを考える
- コンポーネント→UIを独立した、再利用可能な部品に分割
- Reactは小文字で始まるコンポーネントをDOMタグとして扱うため、ユーザー定義のコンポーネントは大文字で始めること
- Propsは自身へ入力されたものを変更しようとせず、同じ入力に対して同じ結果を返す、純関数のように振舞わねばならない
- 複数の子要素からデータを集めたり、2つの子コンポーネントにやり取りさせたい場合は、親の方で子のstateを保持する(子のstateを親コンポーネントにリフトアップする)
- stateを持たない、renderメソッドだけを有するコンポーネントを、シンプルに書くには、関数コンポーネントとして書く。->Hooksというのを使えばfunctionalComponentでもStateを持たせることができる?みたい
- Hooksを学ぶべし
- 関心を分離　useEffect


### Udemy 「Reactに入門した人のためのもっとReactが楽しくなるステップアップコース完全版」メモ
- 親コンポーネントが再レンダリングされたが、子コンポーネントに渡しているpropsに変更がない場合に、再レンダリングを制御 → `memo()`で子コンポーネントを囲ってあげる
  - 基本的にコンポーネントはmemo()で囲ってあげるとよい （あんまり書いててmemo()を見かけないが、reduxとかMobXを利用しているため？）
- アロー関数で関数を定義している場合、アロー関数は呼び出すたびに新たな関数という判定になる。そのため、内容に変化がなくてもpropsに変更があったと判定され、子コンポーネントの再レンダリングが発生してしまう
  - 処理自体に変更がない場合は`useCallback()`で囲ってあげる。useEffect()と同様に、第二引数には依存配列を渡してあげる
- 変数自体をmemo化する場合はuseMemo()を使用する。変数の内容が計算量の多い処理の場合などに有効になる。

まとめ
- コンポーネントのmemo化 → memo()
- 関数のmemo化 → useCallback()
- 変数のmemo化 → useMemo()

### コードレビューで受けたアドバイス
#### useEffect()やuseMemo()のdepsは指定するようにしましょう
バグの原因になる

